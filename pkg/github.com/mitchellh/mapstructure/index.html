<!DOCTYPE html>
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<meta name="theme-color" content="#375EAB">

  <title>mapstructure - Go Documentation Server</title>

<link type="text/css" rel="stylesheet" href="/lib/godoc/style.css">

<script>window.initFuncs = [];</script>
<script src="/lib/godoc/jquery.js" defer></script>



<script>var goVersion = "go1.14.2";</script>
<script src="/lib/godoc/godocs.js" defer></script>
</head>
<body>

<div id='lowframe' style="position: fixed; bottom: 0; left: 0; height: 0; width: 100%; border-top: thin solid grey; background-color: white; overflow: auto;">
...
</div><!-- #lowframe -->

<div id="topbar" class="wide"><div class="container">
<div class="top-heading" id="heading-wide"><a href="/pkg/">Go Documentation Server</a></div>
<div class="top-heading" id="heading-narrow"><a href="/pkg/">GoDoc</a></div>
<a href="#" id="menu-button"><span id="menu-button-arrow">&#9661;</span></a>
<form method="GET" action="/search">
<div id="menu">

<span class="search-box"><input type="search" id="search" name="q" placeholder="Search" aria-label="Search" required><button type="submit"><span><!-- magnifying glass: --><svg width="24" height="24" viewBox="0 0 24 24"><title>submit search</title><path d="M15.5 14h-.79l-.28-.27C15.41 12.59 16 11.11 16 9.5 16 5.91 13.09 3 9.5 3S3 5.91 3 9.5 5.91 16 9.5 16c1.61 0 3.09-.59 4.23-1.57l.27.28v.79l5 4.99L20.49 19l-4.99-5zm-6 0C7.01 14 5 11.99 5 9.5S7.01 5 9.5 5 14 7.01 14 9.5 11.99 14 9.5 14z"/><path d="M0 0h24v24H0z" fill="none"/></svg></span></button></span>
</div>
</form>

</div></div>



<div id="page" class="wide">
<div class="container">


  <h1>
    Package mapstructure
    <span class="text-muted"></span>
  </h1>







<div id="nav"></div>


<!--
	Copyright 2009 The Go Authors. All rights reserved.
	Use of this source code is governed by a BSD-style
	license that can be found in the LICENSE file.
-->
<!--
	Note: Static (i.e., not template-generated) href and id
	attributes start with "pkg-" to make it impossible for
	them to conflict with generated attributes (some of which
	correspond to Go identifiers).
-->

	<script>
	document.ANALYSIS_DATA = null;
	document.CALLGRAPH = null;
	</script>

	
		
		<div id="short-nav">
			<dl>
			<dd><code>import "github.com/mitchellh/mapstructure"</code></dd>
			</dl>
			<dl>
			<dd><a href="#pkg-overview" class="overviewLink">Overview</a></dd>
			<dd><a href="#pkg-index" class="indexLink">Index</a></dd>
			
				<dd><a href="#pkg-examples" class="examplesLink">Examples</a></dd>
			
			
			</dl>
		</div>
		<!-- The package's Name is printed as title by the top-level template -->
		<div id="pkg-overview" class="toggleVisible">
			<div class="collapsed">
				<h2 class="toggleButton" title="Click to show Overview section">Overview ▹</h2>
			</div>
			<div class="expanded">
				<h2 class="toggleButton" title="Click to hide Overview section">Overview ▾</h2>
				<p>
Package mapstructure exposes functionality to convert one arbitrary
Go type into another, typically to convert a map[string]interface{}
into a native Go structure.
</p>
<p>
The Go structure can be arbitrarily complex, containing slices,
other structs, etc. and the decoder will properly decode nested
maps and so on into the proper structures in the native Go struct.
See the examples to see what the decoder is capable of.
</p>
<p>
The simplest function to start with is Decode.
</p>
<h3 id="hdr-Field_Tags">Field Tags</h3>
<p>
When decoding to a struct, mapstructure will use the field name by
default to perform the mapping. For example, if a struct has a field
&#34;Username&#34; then mapstructure will look for a key in the source value
of &#34;username&#34; (case insensitive).
</p>
<pre>type User struct {
    Username string
}
</pre>
<p>
You can change the behavior of mapstructure by using struct tags.
The default struct tag that mapstructure looks for is &#34;mapstructure&#34;
but you can customize it using DecoderConfig.
</p>
<h3 id="hdr-Renaming_Fields">Renaming Fields</h3>
<p>
To rename the key that mapstructure looks for, use the &#34;mapstructure&#34;
tag and set a value directly. For example, to change the &#34;username&#34; example
above to &#34;user&#34;:
</p>
<pre>type User struct {
    Username string `mapstructure:&#34;user&#34;`
}
</pre>
<h3 id="hdr-Embedded_Structs_and_Squashing">Embedded Structs and Squashing</h3>
<p>
Embedded structs are treated as if they&#39;re another field with that name.
By default, the two structs below are equivalent when decoding with
mapstructure:
</p>
<pre>type Person struct {
    Name string
}

type Friend struct {
    Person
}

type Friend struct {
    Person Person
}
</pre>
<p>
This would require an input that looks like below:
</p>
<pre>map[string]interface{}{
    &#34;person&#34;: map[string]interface{}{&#34;name&#34;: &#34;alice&#34;},
}
</pre>
<p>
If your &#34;person&#34; value is NOT nested, then you can append &#34;,squash&#34; to
your tag value and mapstructure will treat it as if the embedded struct
were part of the struct directly. Example:
</p>
<pre>type Friend struct {
    Person `mapstructure:&#34;,squash&#34;`
}
</pre>
<p>
Now the following input would be accepted:
</p>
<pre>map[string]interface{}{
    &#34;name&#34;: &#34;alice&#34;,
}
</pre>
<p>
When decoding from a struct to a map, the squash tag squashes the struct
fields into a single map. Using the example structs from above:
</p>
<pre>Friend{Person: Person{Name: &#34;alice&#34;}}
</pre>
<p>
Will be decoded into a map:
</p>
<pre>map[string]interface{}{
    &#34;name&#34;: &#34;alice&#34;,
}
</pre>
<p>
DecoderConfig has a field that changes the behavior of mapstructure
to always squash embedded structs.
</p>
<h3 id="hdr-Remainder_Values">Remainder Values</h3>
<p>
If there are any unmapped keys in the source value, mapstructure by
default will silently ignore them. You can error by setting ErrorUnused
in DecoderConfig. If you&#39;re using Metadata you can also maintain a slice
of the unused keys.
</p>
<p>
You can also use the &#34;,remain&#34; suffix on your tag to collect all unused
values in a map. The field with this tag MUST be a map type and should
probably be a &#34;map[string]interface{}&#34; or &#34;map[interface{}]interface{}&#34;.
See example below:
</p>
<pre>type Friend struct {
    Name  string
    Other map[string]interface{} `mapstructure:&#34;,remain&#34;`
}
</pre>
<p>
Given the input below, Other would be populated with the other
values that weren&#39;t used (everything but &#34;name&#34;):
</p>
<pre>map[string]interface{}{
    &#34;name&#34;:    &#34;bob&#34;,
    &#34;address&#34;: &#34;123 Maple St.&#34;,
}
</pre>
<h3 id="hdr-Omit_Empty_Values">Omit Empty Values</h3>
<p>
When decoding from a struct to any other value, you may use the
&#34;,omitempty&#34; suffix on your tag to omit that value if it equates to
the zero value. The zero value of all types is specified in the Go
specification.
</p>
<p>
For example, the zero type of a numeric type is zero (&#34;0&#34;). If the struct
field value is zero and a numeric type, the field is empty, and it won&#39;t
be encoded into the destination type.
</p>
<pre>type Source {
    Age int `mapstructure:&#34;,omitempty&#34;`
}
</pre>
<h3 id="hdr-Unexported_fields">Unexported fields</h3>
<p>
Since unexported (private) struct fields cannot be set outside the package
where they are defined, the decoder will simply skip them.
</p>
<p>
For this output type definition:
</p>
<pre>type Exported struct {
    private string // this unexported field will be skipped
    Public string
}
</pre>
<p>
Using this map as input:
</p>
<pre>map[string]interface{}{
    &#34;private&#34;: &#34;I will be ignored&#34;,
    &#34;Public&#34;:  &#34;I made it through!&#34;,
}
</pre>
<p>
The following struct will be decoded:
</p>
<pre>type Exported struct {
    private: &#34;&#34; // field is left with an empty string (zero value)
    Public: &#34;I made it through!&#34;
}
</pre>
<h3 id="hdr-Other_Configuration">Other Configuration</h3>
<p>
mapstructure is highly configurable. See the DecoderConfig struct
for other features and options that are supported.
</p>

				
			</div>
		</div>

		<div id="pkg-index" class="toggleVisible">
		<div class="collapsed">
			<h2 class="toggleButton" title="Click to show Index section">Index ▹</h2>
		</div>
		<div class="expanded">
			<h2 class="toggleButton" title="Click to hide Index section">Index ▾</h2>

		<!-- Table of contents for API; must be named manual-nav to turn off auto nav. -->
			<div id="manual-nav">
			<dl>
			
			
			
				
				<dd><a href="#Decode">func Decode(input interface{}, output interface{}) error</a></dd>
			
				
				<dd><a href="#DecodeHookExec">func DecodeHookExec(raw DecodeHookFunc, from reflect.Value, to reflect.Value) (interface{}, error)</a></dd>
			
				
				<dd><a href="#DecodeMetadata">func DecodeMetadata(input interface{}, output interface{}, metadata *Metadata) error</a></dd>
			
				
				<dd><a href="#WeakDecode">func WeakDecode(input, output interface{}) error</a></dd>
			
				
				<dd><a href="#WeakDecodeMetadata">func WeakDecodeMetadata(input interface{}, output interface{}, metadata *Metadata) error</a></dd>
			
				
				<dd><a href="#WeaklyTypedHook">func WeaklyTypedHook(f reflect.Kind, t reflect.Kind, data interface{}) (interface{}, error)</a></dd>
			
			
				
				<dd><a href="#DecodeHookFunc">type DecodeHookFunc</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#ComposeDecodeHookFunc">func ComposeDecodeHookFunc(fs ...DecodeHookFunc) DecodeHookFunc</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#RecursiveStructToMapHookFunc">func RecursiveStructToMapHookFunc() DecodeHookFunc</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#StringToIPHookFunc">func StringToIPHookFunc() DecodeHookFunc</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#StringToIPNetHookFunc">func StringToIPNetHookFunc() DecodeHookFunc</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#StringToSliceHookFunc">func StringToSliceHookFunc(sep string) DecodeHookFunc</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#StringToTimeDurationHookFunc">func StringToTimeDurationHookFunc() DecodeHookFunc</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#StringToTimeHookFunc">func StringToTimeHookFunc(layout string) DecodeHookFunc</a></dd>
				
				
			
				
				<dd><a href="#DecodeHookFuncKind">type DecodeHookFuncKind</a></dd>
				
				
			
				
				<dd><a href="#DecodeHookFuncType">type DecodeHookFuncType</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#TextUnmarshallerHookFunc">func TextUnmarshallerHookFunc() DecodeHookFuncType</a></dd>
				
				
			
				
				<dd><a href="#DecodeHookFuncValue">type DecodeHookFuncValue</a></dd>
				
				
			
				
				<dd><a href="#Decoder">type Decoder</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#NewDecoder">func NewDecoder(config *DecoderConfig) (*Decoder, error)</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#Decoder.Decode">func (d *Decoder) Decode(input interface{}) error</a></dd>
				
			
				
				<dd><a href="#DecoderConfig">type DecoderConfig</a></dd>
				
				
			
				
				<dd><a href="#Error">type Error</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#Error.Error">func (e *Error) Error() string</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Error.WrappedErrors">func (e *Error) WrappedErrors() []error</a></dd>
				
			
				
				<dd><a href="#Metadata">type Metadata</a></dd>
				
				
			
			
			</dl>
			</div><!-- #manual-nav -->

		
		<div id="pkg-examples">
			<h3>Examples</h3>
			<div class="js-expandAll expandAll collapsed">(Expand All)</div>
			<dl>
			
			<dd><a class="exampleLink" href="#example_Decode">Decode</a></dd>
			
			<dd><a class="exampleLink" href="#example_Decode_embeddedStruct">Decode (EmbeddedStruct)</a></dd>
			
			<dd><a class="exampleLink" href="#example_Decode_errors">Decode (Errors)</a></dd>
			
			<dd><a class="exampleLink" href="#example_Decode_metadata">Decode (Metadata)</a></dd>
			
			<dd><a class="exampleLink" href="#example_Decode_omitempty">Decode (Omitempty)</a></dd>
			
			<dd><a class="exampleLink" href="#example_Decode_remainingData">Decode (RemainingData)</a></dd>
			
			<dd><a class="exampleLink" href="#example_Decode_tags">Decode (Tags)</a></dd>
			
			<dd><a class="exampleLink" href="#example_Decode_weaklyTypedInput">Decode (WeaklyTypedInput)</a></dd>
			
			</dl>
		</div>
		

		
			<h3>Package files</h3>
			<p>
			<span style="font-size:90%">
			
				<a href="/src/github.com/mitchellh/mapstructure/decode_hooks.go">decode_hooks.go</a>
			
				<a href="/src/github.com/mitchellh/mapstructure/error.go">error.go</a>
			
				<a href="/src/github.com/mitchellh/mapstructure/mapstructure.go">mapstructure.go</a>
			
			</span>
			</p>
		
		</div><!-- .expanded -->
		</div><!-- #pkg-index -->

		

		
		
		
			
			
			<h2 id="Decode">func <a href="/src/github.com/mitchellh/mapstructure/mapstructure.go?s=9816:9872#L276">Decode</a>
				<a class="permalink" href="#Decode">&#xb6;</a>
				
				
			</h2>
			<pre>func Decode(input interface{}, output interface{}) <a href="/pkg/builtin/#error">error</a></pre>
			<p>
Decode takes an input structure and uses reflection to translate it to
the output structure. output must be a pointer to a map or struct.
</p>

			<div id="example_Decode" class="toggle">
	<div class="collapsed">
		<p class="exampleHeading toggleButton">▹ <span class="text">Example</span></p>
	</div>
	<div class="expanded">
		<p class="exampleHeading toggleButton">▾ <span class="text">Example</span></p>
		
		
		
			<p>Code:</p>
			<pre class="code">type Person struct {
    Name   string
    Age    int
    Emails []string
    Extra  map[string]string
}

<span class="comment">// This input can come from anywhere, but typically comes from</span>
<span class="comment">// something like decoding JSON where we&#39;re not quite sure of the</span>
<span class="comment">// struct initially.</span>
input := map[string]interface{}{
    &#34;name&#34;:   &#34;Mitchell&#34;,
    &#34;age&#34;:    91,
    &#34;emails&#34;: []string{&#34;one&#34;, &#34;two&#34;, &#34;three&#34;},
    &#34;extra&#34;: map[string]string{
        &#34;twitter&#34;: &#34;mitchellh&#34;,
    },
}

var result Person
err := Decode(input, &amp;result)
if err != nil {
    panic(err)
}

fmt.Printf(&#34;%#v&#34;, result)
<span class="comment"></pre>
			
			<p>Output:</p>
			<pre class="output">mapstructure.Person{Name:&#34;Mitchell&#34;, Age:91, Emails:[]string{&#34;one&#34;, &#34;two&#34;, &#34;three&#34;}, Extra:map[string]string{&#34;twitter&#34;:&#34;mitchellh&#34;}}
</pre>
			
		
	</div>
</div>
<div id="example_Decode_embeddedStruct" class="toggle">
	<div class="collapsed">
		<p class="exampleHeading toggleButton">▹ <span class="text">Example (EmbeddedStruct)</span></p>
	</div>
	<div class="expanded">
		<p class="exampleHeading toggleButton">▾ <span class="text">Example (EmbeddedStruct)</span></p>
		
		
		
			<p>Code:</p>
			<pre class="code"><span class="comment">// Squashing multiple embedded structs is allowed using the squash tag.</span>
<span class="comment">// This is demonstrated by creating a composite struct of multiple types</span>
<span class="comment">// and decoding into it. In this case, a person can carry with it both</span>
<span class="comment">// a Family and a Location, as well as their own FirstName.</span>
type Family struct {
    LastName string
}
type Location struct {
    City string
}
type Person struct {
    Family    `mapstructure:&#34;,squash&#34;`
    Location  `mapstructure:&#34;,squash&#34;`
    FirstName string
}

input := map[string]interface{}{
    &#34;FirstName&#34;: &#34;Mitchell&#34;,
    &#34;LastName&#34;:  &#34;Hashimoto&#34;,
    &#34;City&#34;:      &#34;San Francisco&#34;,
}

var result Person
err := Decode(input, &amp;result)
if err != nil {
    panic(err)
}

fmt.Printf(&#34;%s %s, %s&#34;, result.FirstName, result.LastName, result.City)
<span class="comment"></pre>
			
			<p>Output:</p>
			<pre class="output">Mitchell Hashimoto, San Francisco
</pre>
			
		
	</div>
</div>
<div id="example_Decode_errors" class="toggle">
	<div class="collapsed">
		<p class="exampleHeading toggleButton">▹ <span class="text">Example (Errors)</span></p>
	</div>
	<div class="expanded">
		<p class="exampleHeading toggleButton">▾ <span class="text">Example (Errors)</span></p>
		
		
		
			<p>Code:</p>
			<pre class="code">type Person struct {
    Name   string
    Age    int
    Emails []string
    Extra  map[string]string
}

<span class="comment">// This input can come from anywhere, but typically comes from</span>
<span class="comment">// something like decoding JSON where we&#39;re not quite sure of the</span>
<span class="comment">// struct initially.</span>
input := map[string]interface{}{
    &#34;name&#34;:   123,
    &#34;age&#34;:    &#34;bad value&#34;,
    &#34;emails&#34;: []int{1, 2, 3},
}

var result Person
err := Decode(input, &amp;result)
if err == nil {
    panic(&#34;should have an error&#34;)
}

fmt.Println(err.Error())
<span class="comment"></pre>
			
			<p>Output:</p>
			<pre class="output">5 error(s) decoding:

* &#39;Age&#39; expected type &#39;int&#39;, got unconvertible type &#39;string&#39;, value: &#39;bad value&#39;
* &#39;Emails[0]&#39; expected type &#39;string&#39;, got unconvertible type &#39;int&#39;, value: &#39;1&#39;
* &#39;Emails[1]&#39; expected type &#39;string&#39;, got unconvertible type &#39;int&#39;, value: &#39;2&#39;
* &#39;Emails[2]&#39; expected type &#39;string&#39;, got unconvertible type &#39;int&#39;, value: &#39;3&#39;
* &#39;Name&#39; expected type &#39;string&#39;, got unconvertible type &#39;int&#39;, value: &#39;123&#39;
</pre>
			
		
	</div>
</div>
<div id="example_Decode_metadata" class="toggle">
	<div class="collapsed">
		<p class="exampleHeading toggleButton">▹ <span class="text">Example (Metadata)</span></p>
	</div>
	<div class="expanded">
		<p class="exampleHeading toggleButton">▾ <span class="text">Example (Metadata)</span></p>
		
		
		
			<p>Code:</p>
			<pre class="code">type Person struct {
    Name string
    Age  int
}

<span class="comment">// This input can come from anywhere, but typically comes from</span>
<span class="comment">// something like decoding JSON where we&#39;re not quite sure of the</span>
<span class="comment">// struct initially.</span>
input := map[string]interface{}{
    &#34;name&#34;:  &#34;Mitchell&#34;,
    &#34;age&#34;:   91,
    &#34;email&#34;: &#34;foo@bar.com&#34;,
}

<span class="comment">// For metadata, we make a more advanced DecoderConfig so we can</span>
<span class="comment">// more finely configure the decoder that is used. In this case, we</span>
<span class="comment">// just tell the decoder we want to track metadata.</span>
var md Metadata
var result Person
config := &amp;DecoderConfig{
    Metadata: &amp;md,
    Result:   &amp;result,
}

decoder, err := NewDecoder(config)
if err != nil {
    panic(err)
}

if err := decoder.Decode(input); err != nil {
    panic(err)
}

fmt.Printf(&#34;Unused keys: %#v&#34;, md.Unused)
<span class="comment"></pre>
			
			<p>Output:</p>
			<pre class="output">Unused keys: []string{&#34;email&#34;}
</pre>
			
		
	</div>
</div>
<div id="example_Decode_omitempty" class="toggle">
	<div class="collapsed">
		<p class="exampleHeading toggleButton">▹ <span class="text">Example (Omitempty)</span></p>
	</div>
	<div class="expanded">
		<p class="exampleHeading toggleButton">▾ <span class="text">Example (Omitempty)</span></p>
		
		
		
			<p>Code:</p>
			<pre class="code"><span class="comment">// Add omitempty annotation to avoid map keys for empty values</span>
type Family struct {
    LastName string
}
type Location struct {
    City string
}
type Person struct {
    *Family   `mapstructure:&#34;,omitempty&#34;`
    *Location `mapstructure:&#34;,omitempty&#34;`
    Age       int
    FirstName string
}

result := &amp;map[string]interface{}{}
input := Person{FirstName: &#34;Somebody&#34;}
err := Decode(input, &amp;result)
if err != nil {
    panic(err)
}

fmt.Printf(&#34;%+v&#34;, result)
<span class="comment"></pre>
			
			<p>Output:</p>
			<pre class="output">&amp;map[Age:0 FirstName:Somebody]
</pre>
			
		
	</div>
</div>
<div id="example_Decode_remainingData" class="toggle">
	<div class="collapsed">
		<p class="exampleHeading toggleButton">▹ <span class="text">Example (RemainingData)</span></p>
	</div>
	<div class="expanded">
		<p class="exampleHeading toggleButton">▾ <span class="text">Example (RemainingData)</span></p>
		
		
		
			<p>Code:</p>
			<pre class="code"><span class="comment">// Note that the mapstructure tags defined in the struct type</span>
<span class="comment">// can indicate which fields the values are mapped to.</span>
type Person struct {
    Name  string
    Age   int
    Other map[string]interface{} `mapstructure:&#34;,remain&#34;`
}

input := map[string]interface{}{
    &#34;name&#34;:  &#34;Mitchell&#34;,
    &#34;age&#34;:   91,
    &#34;email&#34;: &#34;mitchell@example.com&#34;,
}

var result Person
err := Decode(input, &amp;result)
if err != nil {
    panic(err)
}

fmt.Printf(&#34;%#v&#34;, result)
<span class="comment"></pre>
			
			<p>Output:</p>
			<pre class="output">mapstructure.Person{Name:&#34;Mitchell&#34;, Age:91, Other:map[string]interface {}{&#34;email&#34;:&#34;mitchell@example.com&#34;}}
</pre>
			
		
	</div>
</div>
<div id="example_Decode_tags" class="toggle">
	<div class="collapsed">
		<p class="exampleHeading toggleButton">▹ <span class="text">Example (Tags)</span></p>
	</div>
	<div class="expanded">
		<p class="exampleHeading toggleButton">▾ <span class="text">Example (Tags)</span></p>
		
		
		
			<p>Code:</p>
			<pre class="code"><span class="comment">// Note that the mapstructure tags defined in the struct type</span>
<span class="comment">// can indicate which fields the values are mapped to.</span>
type Person struct {
    Name string `mapstructure:&#34;person_name&#34;`
    Age  int    `mapstructure:&#34;person_age&#34;`
}

input := map[string]interface{}{
    &#34;person_name&#34;: &#34;Mitchell&#34;,
    &#34;person_age&#34;:  91,
}

var result Person
err := Decode(input, &amp;result)
if err != nil {
    panic(err)
}

fmt.Printf(&#34;%#v&#34;, result)
<span class="comment"></pre>
			
			<p>Output:</p>
			<pre class="output">mapstructure.Person{Name:&#34;Mitchell&#34;, Age:91}
</pre>
			
		
	</div>
</div>
<div id="example_Decode_weaklyTypedInput" class="toggle">
	<div class="collapsed">
		<p class="exampleHeading toggleButton">▹ <span class="text">Example (WeaklyTypedInput)</span></p>
	</div>
	<div class="expanded">
		<p class="exampleHeading toggleButton">▾ <span class="text">Example (WeaklyTypedInput)</span></p>
		
		
		
			<p>Code:</p>
			<pre class="code">type Person struct {
    Name   string
    Age    int
    Emails []string
}

<span class="comment">// This input can come from anywhere, but typically comes from</span>
<span class="comment">// something like decoding JSON, generated by a weakly typed language</span>
<span class="comment">// such as PHP.</span>
input := map[string]interface{}{
    &#34;name&#34;:   123,                      <span class="comment">// number =&gt; string</span>
    &#34;age&#34;:    &#34;42&#34;,                     <span class="comment">// string =&gt; number</span>
    &#34;emails&#34;: map[string]interface{}{}, <span class="comment">// empty map =&gt; empty array</span>
}

var result Person
config := &amp;DecoderConfig{
    WeaklyTypedInput: true,
    Result:           &amp;result,
}

decoder, err := NewDecoder(config)
if err != nil {
    panic(err)
}

err = decoder.Decode(input)
if err != nil {
    panic(err)
}

fmt.Printf(&#34;%#v&#34;, result)
<span class="comment"></pre>
			
			<p>Output:</p>
			<pre class="output">mapstructure.Person{Name:&#34;123&#34;, Age:42, Emails:[]string{}}
</pre>
			
		
	</div>
</div>

			

		
			
			
			<h2 id="DecodeHookExec">func <a href="/src/github.com/mitchellh/mapstructure/decode_hooks.go?s=1019:1120#L31">DecodeHookExec</a>
				<a class="permalink" href="#DecodeHookExec">&#xb6;</a>
				
				
			</h2>
			<pre>func DecodeHookExec(
    raw <a href="#DecodeHookFunc">DecodeHookFunc</a>,
    from <a href="/pkg/reflect/">reflect</a>.<a href="/pkg/reflect/#Value">Value</a>, to <a href="/pkg/reflect/">reflect</a>.<a href="/pkg/reflect/#Value">Value</a>) (interface{}, <a href="/pkg/builtin/#error">error</a>)</pre>
			<p>
DecodeHookExec executes the given decode hook. This should be used
since it&#39;ll naturally degrade to the older backwards compatible DecodeHookFunc
that took reflect.Kind instead of reflect.Type.
</p>

			
			

		
			
			
			<h2 id="DecodeMetadata">func <a href="/src/github.com/mitchellh/mapstructure/mapstructure.go?s=10552:10636#L309">DecodeMetadata</a>
				<a class="permalink" href="#DecodeMetadata">&#xb6;</a>
				
				
			</h2>
			<pre>func DecodeMetadata(input interface{}, output interface{}, metadata *<a href="#Metadata">Metadata</a>) <a href="/pkg/builtin/#error">error</a></pre>
			<p>
DecodeMetadata is the same as Decode, but is shorthand to
enable metadata collection. See DecoderConfig for more info.
</p>

			
			

		
			
			
			<h2 id="WeakDecode">func <a href="/src/github.com/mitchellh/mapstructure/mapstructure.go?s=10163:10211#L292">WeakDecode</a>
				<a class="permalink" href="#WeakDecode">&#xb6;</a>
				
				
			</h2>
			<pre>func WeakDecode(input, output interface{}) <a href="/pkg/builtin/#error">error</a></pre>
			<p>
WeakDecode is the same as Decode but is shorthand to enable
WeaklyTypedInput. See DecoderConfig for more info.
</p>

			
			

		
			
			
			<h2 id="WeakDecodeMetadata">func <a href="/src/github.com/mitchellh/mapstructure/mapstructure.go?s=10973:11061#L326">WeakDecodeMetadata</a>
				<a class="permalink" href="#WeakDecodeMetadata">&#xb6;</a>
				
				
			</h2>
			<pre>func WeakDecodeMetadata(input interface{}, output interface{}, metadata *<a href="#Metadata">Metadata</a>) <a href="/pkg/builtin/#error">error</a></pre>
			<p>
WeakDecodeMetadata is the same as Decode, but is shorthand to
enable both WeaklyTypedInput and metadata collection. See
DecoderConfig for more info.
</p>

			
			

		
			
			
			<h2 id="WeaklyTypedHook">func <a href="/src/github.com/mitchellh/mapstructure/decode_hooks.go?s=4524:4619#L176">WeaklyTypedHook</a>
				<a class="permalink" href="#WeaklyTypedHook">&#xb6;</a>
				
				
			</h2>
			<pre>func WeaklyTypedHook(
    f <a href="/pkg/reflect/">reflect</a>.<a href="/pkg/reflect/#Kind">Kind</a>,
    t <a href="/pkg/reflect/">reflect</a>.<a href="/pkg/reflect/#Kind">Kind</a>,
    data interface{}) (interface{}, <a href="/pkg/builtin/#error">error</a>)</pre>
			<p>
WeaklyTypedHook is a DecodeHookFunc which adds support for weak typing to
the decoder.
</p>
<p>
Note that this is significantly different from the WeaklyTypedInput option
of the DecoderConfig.
</p>

			
			

		
		
			
			
			<h2 id="DecodeHookFunc">type <a href="/src/github.com/mitchellh/mapstructure/mapstructure.go?s=5725:5756#L175">DecodeHookFunc</a>
				<a class="permalink" href="#DecodeHookFunc">&#xb6;</a>
				
				
			</h2>
			<p>
DecodeHookFunc is the callback function that can be used for
data transformations. See &#34;DecodeHook&#34; in the DecoderConfig
struct.
</p>
<p>
The type must be one of DecodeHookFuncType, DecodeHookFuncKind, or
DecodeHookFuncValue.
Values are a superset of Types (Values can return types), and Types are a
superset of Kinds (Types can return Kinds) and are generally a richer thing
to use, but Kinds are simpler if you only need those.
</p>
<p>
The reason DecodeHookFunc is multi-typed is for backwards compatibility:
we started with Kinds and then realized Types were the better solution,
but have a promise to not break backwards compat so we now support
both.
</p>

			<pre>type DecodeHookFunc interface{}</pre>

			

			

			
			
			

			
				
				<h3 id="ComposeDecodeHookFunc">func <a href="/src/github.com/mitchellh/mapstructure/decode_hooks.go?s=1658:1721#L52">ComposeDecodeHookFunc</a>
					<a class="permalink" href="#ComposeDecodeHookFunc">&#xb6;</a>
					
					
				</h3>
				<pre>func ComposeDecodeHookFunc(fs ...<a href="#DecodeHookFunc">DecodeHookFunc</a>) <a href="#DecodeHookFunc">DecodeHookFunc</a></pre>
				<p>
ComposeDecodeHookFunc creates a single DecodeHookFunc that
automatically composes multiple DecodeHookFuncs.
</p>
<p>
The composed funcs are called in order, with the result of the
previous transformation.
</p>

				
				
			
				
				<h3 id="RecursiveStructToMapHookFunc">func <a href="/src/github.com/mitchellh/mapstructure/decode_hooks.go?s=5239:5289#L207">RecursiveStructToMapHookFunc</a>
					<a class="permalink" href="#RecursiveStructToMapHookFunc">&#xb6;</a>
					
					
				</h3>
				<pre>func RecursiveStructToMapHookFunc() <a href="#DecodeHookFunc">DecodeHookFunc</a></pre>
				
				
				
			
				
				<h3 id="StringToIPHookFunc">func <a href="/src/github.com/mitchellh/mapstructure/decode_hooks.go?s=3016:3056#L110">StringToIPHookFunc</a>
					<a class="permalink" href="#StringToIPHookFunc">&#xb6;</a>
					
					
				</h3>
				<pre>func StringToIPHookFunc() <a href="#DecodeHookFunc">DecodeHookFunc</a></pre>
				<p>
StringToIPHookFunc returns a DecodeHookFunc that converts
strings to net.IP
</p>

				
				
			
				
				<h3 id="StringToIPNetHookFunc">func <a href="/src/github.com/mitchellh/mapstructure/decode_hooks.go?s=3528:3571#L134">StringToIPNetHookFunc</a>
					<a class="permalink" href="#StringToIPNetHookFunc">&#xb6;</a>
					
					
				</h3>
				<pre>func StringToIPNetHookFunc() <a href="#DecodeHookFunc">DecodeHookFunc</a></pre>
				<p>
StringToIPNetHookFunc returns a DecodeHookFunc that converts
strings to net.IPNet
</p>

				
				
			
				
				<h3 id="StringToSliceHookFunc">func <a href="/src/github.com/mitchellh/mapstructure/decode_hooks.go?s=2146:2199#L71">StringToSliceHookFunc</a>
					<a class="permalink" href="#StringToSliceHookFunc">&#xb6;</a>
					
					
				</h3>
				<pre>func StringToSliceHookFunc(sep <a href="/pkg/builtin/#string">string</a>) <a href="#DecodeHookFunc">DecodeHookFunc</a></pre>
				<p>
StringToSliceHookFunc returns a DecodeHookFunc that converts
string to []string by splitting on the given sep.
</p>

				
				
			
				
				<h3 id="StringToTimeDurationHookFunc">func <a href="/src/github.com/mitchellh/mapstructure/decode_hooks.go?s=2584:2634#L91">StringToTimeDurationHookFunc</a>
					<a class="permalink" href="#StringToTimeDurationHookFunc">&#xb6;</a>
					
					
				</h3>
				<pre>func StringToTimeDurationHookFunc() <a href="#DecodeHookFunc">DecodeHookFunc</a></pre>
				<p>
StringToTimeDurationHookFunc returns a DecodeHookFunc that converts
strings to time.Duration.
</p>

				
				
			
				
				<h3 id="StringToTimeHookFunc">func <a href="/src/github.com/mitchellh/mapstructure/decode_hooks.go?s=3975:4030#L154">StringToTimeHookFunc</a>
					<a class="permalink" href="#StringToTimeHookFunc">&#xb6;</a>
					
					
				</h3>
				<pre>func StringToTimeHookFunc(layout <a href="/pkg/builtin/#string">string</a>) <a href="#DecodeHookFunc">DecodeHookFunc</a></pre>
				<p>
StringToTimeHookFunc returns a DecodeHookFunc that converts
strings to time.Time.
</p>

				
				
			

			
		
			
			
			<h2 id="DecodeHookFuncKind">type <a href="/src/github.com/mitchellh/mapstructure/mapstructure.go?s=6065:6155#L183">DecodeHookFuncKind</a>
				<a class="permalink" href="#DecodeHookFuncKind">&#xb6;</a>
				
				
			</h2>
			<p>
DecodeHookFuncKind is a DecodeHookFunc which knows only the Kinds of the
source and target types.
</p>

			<pre>type DecodeHookFuncKind func(<a href="/pkg/reflect/">reflect</a>.<a href="/pkg/reflect/#Kind">Kind</a>, <a href="/pkg/reflect/">reflect</a>.<a href="/pkg/reflect/#Kind">Kind</a>, interface{}) (interface{}, <a href="/pkg/builtin/#error">error</a>)</pre>

			

			

			
			
			

			

			
		
			
			
			<h2 id="DecodeHookFuncType">type <a href="/src/github.com/mitchellh/mapstructure/mapstructure.go?s=5869:5959#L179">DecodeHookFuncType</a>
				<a class="permalink" href="#DecodeHookFuncType">&#xb6;</a>
				
				
			</h2>
			<p>
DecodeHookFuncType is a DecodeHookFunc which has complete information about
the source and target types.
</p>

			<pre>type DecodeHookFuncType func(<a href="/pkg/reflect/">reflect</a>.<a href="/pkg/reflect/#Type">Type</a>, <a href="/pkg/reflect/">reflect</a>.<a href="/pkg/reflect/#Type">Type</a>, interface{}) (interface{}, <a href="/pkg/builtin/#error">error</a>)</pre>

			

			

			
			
			

			
				
				<h3 id="TextUnmarshallerHookFunc">func <a href="/src/github.com/mitchellh/mapstructure/decode_hooks.go?s=5823:5873#L228">TextUnmarshallerHookFunc</a>
					<a class="permalink" href="#TextUnmarshallerHookFunc">&#xb6;</a>
					
					
				</h3>
				<pre>func TextUnmarshallerHookFunc() <a href="#DecodeHookFuncType">DecodeHookFuncType</a></pre>
				<p>
TextUnmarshallerHookFunc returns a DecodeHookFunc that applies
strings to the UnmarshalText function, when the target type
implements the encoding.TextUnmarshaler interface
</p>

				
				
			

			
		
			
			
			<h2 id="DecodeHookFuncValue">type <a href="/src/github.com/mitchellh/mapstructure/mapstructure.go?s=6265:6353#L187">DecodeHookFuncValue</a>
				<a class="permalink" href="#DecodeHookFuncValue">&#xb6;</a>
				
				
			</h2>
			<p>
DecodeHookFuncRaw is a DecodeHookFunc which has complete access to both the source and target
values.
</p>

			<pre>type DecodeHookFuncValue func(from <a href="/pkg/reflect/">reflect</a>.<a href="/pkg/reflect/#Value">Value</a>, to <a href="/pkg/reflect/">reflect</a>.<a href="/pkg/reflect/#Value">Value</a>) (interface{}, <a href="/pkg/builtin/#error">error</a>)</pre>

			

			

			
			
			

			

			
		
			
			
			<h2 id="Decoder">type <a href="/src/github.com/mitchellh/mapstructure/mapstructure.go?s=9239:9285#L259">Decoder</a>
				<a class="permalink" href="#Decoder">&#xb6;</a>
				
				
			</h2>
			<p>
A Decoder takes a raw interface value and turns it into structured
data, keeping track of rich error information along the way in case
anything goes wrong. Unlike the basic top-level Decode method, you can
more finely control how the Decoder behaves using the DecoderConfig
structure. The top-level Decode method is just a convenience that sets
up the most basic Decoder.
</p>

			<pre>type Decoder struct {
    <span class="comment">// contains filtered or unexported fields</span>
}
</pre>

			

			

			
			
			

			
				
				<h3 id="NewDecoder">func <a href="/src/github.com/mitchellh/mapstructure/mapstructure.go?s=11434:11490#L344">NewDecoder</a>
					<a class="permalink" href="#NewDecoder">&#xb6;</a>
					
					
				</h3>
				<pre>func NewDecoder(config *<a href="#DecoderConfig">DecoderConfig</a>) (*<a href="#Decoder">Decoder</a>, <a href="/pkg/builtin/#error">error</a>)</pre>
				<p>
NewDecoder returns a new decoder for the given configuration. Once
a decoder has been returned, the same configuration must not be used
again.
</p>

				
				
			

			
				
				<h3 id="Decoder.Decode">func (*Decoder) <a href="/src/github.com/mitchellh/mapstructure/mapstructure.go?s=12165:12214#L378">Decode</a>
					<a class="permalink" href="#Decoder.Decode">&#xb6;</a>
					
					
				</h3>
				<pre>func (d *<a href="#Decoder">Decoder</a>) Decode(input interface{}) <a href="/pkg/builtin/#error">error</a></pre>
				<p>
Decode decodes the given raw interface to the target pointer specified
by the configuration.
</p>

				
				
				
			
		
			
			
			<h2 id="DecoderConfig">type <a href="/src/github.com/mitchellh/mapstructure/mapstructure.go?s=6490:8847#L191">DecoderConfig</a>
				<a class="permalink" href="#DecoderConfig">&#xb6;</a>
				
				
			</h2>
			<p>
DecoderConfig is the configuration that is used to create a new decoder
and allows customization of various aspects of decoding.
</p>

			<pre>type DecoderConfig struct {
<span id="DecoderConfig.DecodeHook"></span>    <span class="comment">// DecodeHook, if set, will be called before any decoding and any</span>
    <span class="comment">// type conversion (if WeaklyTypedInput is on). This lets you modify</span>
    <span class="comment">// the values before they&#39;re set down onto the resulting struct. The</span>
    <span class="comment">// DecodeHook is called for every map and value in the input. This means</span>
    <span class="comment">// that if a struct has embedded fields with squash tags the decode hook</span>
    <span class="comment">// is called only once with all of the input data, not once for each</span>
    <span class="comment">// embedded struct.</span>
    <span class="comment">//</span>
    <span class="comment">// If an error is returned, the entire decode will fail with that error.</span>
    DecodeHook <a href="#DecodeHookFunc">DecodeHookFunc</a>

    <span class="comment">// If ErrorUnused is true, then it is an error for there to exist</span>
    <span class="comment">// keys in the original map that were unused in the decoding process</span>
    <span class="comment">// (extra keys).</span>
<span id="DecoderConfig.ErrorUnused"></span>    ErrorUnused <a href="/pkg/builtin/#bool">bool</a>

<span id="DecoderConfig.ZeroFields"></span>    <span class="comment">// ZeroFields, if set to true, will zero fields before writing them.</span>
    <span class="comment">// For example, a map will be emptied before decoded values are put in</span>
    <span class="comment">// it. If this is false, a map will be merged.</span>
    ZeroFields <a href="/pkg/builtin/#bool">bool</a>

    <span class="comment">// If WeaklyTypedInput is true, the decoder will make the following</span>
    <span class="comment">// &#34;weak&#34; conversions:</span>
    <span class="comment">//</span>
    <span class="comment">//   - bools to string (true = &#34;1&#34;, false = &#34;0&#34;)</span>
    <span class="comment">//   - numbers to string (base 10)</span>
    <span class="comment">//   - bools to int/uint (true = 1, false = 0)</span>
    <span class="comment">//   - strings to int/uint (base implied by prefix)</span>
    <span class="comment">//   - int to bool (true if value != 0)</span>
    <span class="comment">//   - string to bool (accepts: 1, t, T, TRUE, true, True, 0, f, F,</span>
    <span class="comment">//     FALSE, false, False. Anything else is an error)</span>
    <span class="comment">//   - empty array = empty map and vice versa</span>
    <span class="comment">//   - negative numbers to overflowed uint values (base 10)</span>
    <span class="comment">//   - slice of maps to a merged map</span>
    <span class="comment">//   - single values are converted to slices if required. Each</span>
    <span class="comment">//     element is weakly decoded. For example: &#34;4&#34; can become []int{4}</span>
    <span class="comment">//     if the target type is an int slice.</span>
    <span class="comment">//</span>
<span id="DecoderConfig.WeaklyTypedInput"></span>    WeaklyTypedInput <a href="/pkg/builtin/#bool">bool</a>

<span id="DecoderConfig.Squash"></span>    <span class="comment">// Squash will squash embedded structs.  A squash tag may also be</span>
    <span class="comment">// added to an individual struct field using a tag.  For example:</span>
    <span class="comment">//</span>
    <span class="comment">//  type Parent struct {</span>
    <span class="comment">//      Child `mapstructure:&#34;,squash&#34;`</span>
    <span class="comment">//  }</span>
    Squash <a href="/pkg/builtin/#bool">bool</a>

<span id="DecoderConfig.Metadata"></span>    <span class="comment">// Metadata is the struct that will contain extra metadata about</span>
    <span class="comment">// the decoding. If this is nil, then no metadata will be tracked.</span>
    Metadata *<a href="#Metadata">Metadata</a>

<span id="DecoderConfig.Result"></span>    <span class="comment">// Result is a pointer to the struct that will contain the decoded</span>
    <span class="comment">// value.</span>
    Result interface{}

    <span class="comment">// The tag name that mapstructure reads for field names. This</span>
    <span class="comment">// defaults to &#34;mapstructure&#34;</span>
<span id="DecoderConfig.TagName"></span>    TagName <a href="/pkg/builtin/#string">string</a>
}
</pre>

			

			

			
			
			

			

			
		
			
			
			<h2 id="Error">type <a href="/src/github.com/mitchellh/mapstructure/error.go?s=193:231#L2">Error</a>
				<a class="permalink" href="#Error">&#xb6;</a>
				
				
			</h2>
			<p>
Error implements the error interface and can represents multiple
errors that occur in the course of a single decode.
</p>

			<pre>type Error struct {
<span id="Error.Errors"></span>    Errors []<a href="/pkg/builtin/#string">string</a>
}
</pre>

			

			

			
			
			

			

			
				
				<h3 id="Error.Error">func (*Error) <a href="/src/github.com/mitchellh/mapstructure/error.go?s=233:263#L6">Error</a>
					<a class="permalink" href="#Error.Error">&#xb6;</a>
					
					
				</h3>
				<pre>func (e *<a href="#Error">Error</a>) Error() <a href="/pkg/builtin/#string">string</a></pre>
				
				
				
				
			
				
				<h3 id="Error.WrappedErrors">func (*Error) <a href="/src/github.com/mitchellh/mapstructure/error.go?s=651:690#L20">WrappedErrors</a>
					<a class="permalink" href="#Error.WrappedErrors">&#xb6;</a>
					
					
				</h3>
				<pre>func (e *<a href="#Error">Error</a>) WrappedErrors() []<a href="/pkg/builtin/#error">error</a></pre>
				<p>
WrappedErrors implements the errwrap.Wrapper interface to make this
return value more useful with the errwrap and go-multierror libraries.
</p>

				
				
				
			
		
			
			
			<h2 id="Metadata">type <a href="/src/github.com/mitchellh/mapstructure/mapstructure.go?s=9397:9670#L265">Metadata</a>
				<a class="permalink" href="#Metadata">&#xb6;</a>
				
				
			</h2>
			<p>
Metadata contains information about decoding a structure that
is tedious or difficult to get otherwise.
</p>

			<pre>type Metadata struct {
<span id="Metadata.Keys"></span>    <span class="comment">// Keys are the keys of the structure which were successfully decoded</span>
    Keys []<a href="/pkg/builtin/#string">string</a>

<span id="Metadata.Unused"></span>    <span class="comment">// Unused is a slice of keys that were found in the raw value but</span>
    <span class="comment">// weren&#39;t decoded since there was no matching field in the result interface</span>
    Unused []<a href="/pkg/builtin/#string">string</a>
}
</pre>

			

			

			
			
			

			

			
		
	

	







<div id="footer">
Build version go1.14.2.<br>
Except as <a href="https://developers.google.com/site-policies#restrictions">noted</a>,
the content of this page is licensed under the
Creative Commons Attribution 3.0 License,
and code is licensed under a <a href="/LICENSE">BSD license</a>.<br>
<a href="/doc/tos.html">Terms of Service</a> |
<a href="http://www.google.com/intl/en/policies/privacy/">Privacy Policy</a>
</div>

</div><!-- .container -->
</div><!-- #page -->
</body>
</html>
